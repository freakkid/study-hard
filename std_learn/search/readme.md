# **查找**

* 顺序查找：
    - 查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;
    - 当查找不成功时，需要n+1次比较，时间复杂度为O(n);
    - 所以，顺序查找的时间复杂度为O(n)

* 折半查找
    - 最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；
    - 注：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。——《大话数据结构》

* 插值查找
    - 对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择
    - 复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))
* 二叉查找树
    - 它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡

> 红黑树与STL的map实现有关，B+树和B树、2-3树与数据库的实现原理有关

ps: 掌握不熟的有：AVL树、红黑树、2-3树、B树、B+树