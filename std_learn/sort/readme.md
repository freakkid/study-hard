# **排序算法**

> 最重要的是要会根据情景选择算法

1.  + 原表有序或基本有序 直接插入排序或冒泡排序
    + 原表随机排列，快排
    + 其他算法的时间复杂度不受是否有序影响

2.  + 数组数目 n
    + 记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；
    + 关键字的结构及其分布情况；
    + 对排序稳定性的要求

3.  设待排序元素的个数为n
    + 当n较大，则应采用时间复杂度为O(n*logn)的排序方法：快速排序、堆排序或归并排序。
        - 快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；   　
        - 堆排序：如果内存空间允许且要求稳定性的；
        - 归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。

    + 当n较大，内存空间允许，且要求稳定性：归并排序

    + 当n较小，可采用直接插入或直接选择排序。
        - 直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。
        - 直接选择排序：当元素分布有序，如果不要求稳定性，选择直接选择排序。

    + 一般不使用或不直接使用传统的冒泡排序。

    + 基数排序

        它是一种稳定的排序算法，但有一定的局限性：
        1. 关键字可分解；
        2. 记录的关键字位数较少，如果密集更好；
        3. 如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。


[[Data Structure & Algorithm] 八大排序算法](http://www.cnblogs.com/maybe2030/p/4715042.html#_label8)
